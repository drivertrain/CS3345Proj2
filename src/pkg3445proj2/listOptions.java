package pkg3445proj2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;
/**
 *
 * @author Chase Joshua Uphaus
 */
public class listOptions extends javax.swing.JFrame
{

    int sizeOfList;
    long amtComp, amtSwap;
    long timeTaken;
    String sortMethod;
    String order;
    String winner;
    ArrayList<sortResults> results = new ArrayList<>();
    
    public listOptions()
    {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        bindingGroup = new org.jdesktop.beansbinding.BindingGroup();

        resultsLabel = new javax.swing.JLabel();
        typeSort = new javax.swing.JComboBox<>();
        algLabel = new javax.swing.JLabel();
        orderLabel = new javax.swing.JLabel();
        typeOrder = new javax.swing.JComboBox<>();
        listSlider = new javax.swing.JSlider();
        listSizeLabel = new javax.swing.JLabel();
        sizeList = new javax.swing.JTextField();
        genBtn = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JSeparator();
        setupLabel = new javax.swing.JLabel();
        compLabel = new javax.swing.JLabel();
        swapLabel = new javax.swing.JLabel();
        timeLabel = new javax.swing.JLabel();
        amtCompField = new javax.swing.JTextField();
        amtSwapField = new javax.swing.JTextField();
        amtTimeField = new javax.swing.JTextField();
        winnerField = new javax.swing.JTextField();
        winningLane = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        msTimeField = new javax.swing.JTextField();
        currentAlg = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Select List Properties");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        resultsLabel.setFont(new java.awt.Font("Berlin Sans FB", 0, 24)); // NOI18N
        resultsLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        resultsLabel.setText("Results:");

        typeSort.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Insertion Sort", "Selection Sort", "Quick Sort", "Merge Sort", "Heap Sort", "Radix Sort" }));
        typeSort.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                typeSortActionPerformed(evt);
            }
        });

        algLabel.setText("Algotrithm");

        orderLabel.setText("Order:");

        typeOrder.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "In Order", "Reverse Order", "Almost Ordered", "Random" }));

        listSlider.setMaximum(100000);
        listSlider.setPaintLabels(true);
        listSlider.setPaintTicks(true);
        listSlider.setToolTipText("");
        listSlider.setName("Size of List"); // NOI18N

        org.jdesktop.beansbinding.Binding binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, listSlider, org.jdesktop.beansbinding.ELProperty.create("${value}"), listSlider, org.jdesktop.beansbinding.BeanProperty.create("value"), "sizeOfList");
        bindingGroup.addBinding(binding);

        listSlider.addChangeListener(new javax.swing.event.ChangeListener()
        {
            public void stateChanged(javax.swing.event.ChangeEvent evt)
            {
                listSliderStateChanged(evt);
            }
        });

        listSizeLabel.setText("Amount of Elements:");

        sizeList.setEditable(false);
        sizeList.setText("Move Slider");

        genBtn.setText("Create List");
        genBtn.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                genBtnActionPerformed(evt);
            }
        });

        jSeparator2.setOrientation(javax.swing.SwingConstants.VERTICAL);

        setupLabel.setFont(new java.awt.Font("Berlin Sans FB", 0, 24)); // NOI18N
        setupLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        setupLabel.setText("Setup:");

        compLabel.setText("Comparisons:");

        swapLabel.setText("Assignments:");

        timeLabel.setText("Time (hh:mm:ss):");

        amtCompField.setEditable(false);

        amtSwapField.setEditable(false);

        amtTimeField.setEditable(false);

        winnerField.setEditable(false);

        winningLane.setText("Winning Algorithm:");

        jLabel2.setText("Time (ms):");

        msTimeField.setEditable(false);

        currentAlg.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);

        jLabel1.setText("(shortest time)");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(listSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addComponent(genBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 158, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(listSizeLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(sizeList, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(algLabel)
                                    .addComponent(orderLabel))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(typeSort, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(typeOrder, 0, 124, Short.MAX_VALUE)))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(74, 74, 74)
                                .addComponent(setupLabel)))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(57, 57, 57)
                                .addComponent(resultsLabel))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(46, 46, 46)
                                .addComponent(currentAlg, javax.swing.GroupLayout.PREFERRED_SIZE, 133, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(timeLabel)
                                    .addComponent(swapLabel)
                                    .addComponent(compLabel)
                                    .addComponent(jLabel2))
                                .addGap(39, 39, 39)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(amtSwapField, javax.swing.GroupLayout.DEFAULT_SIZE, 109, Short.MAX_VALUE)
                                    .addComponent(amtCompField)
                                    .addComponent(amtTimeField, javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(msTimeField)))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addComponent(jLabel1)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(winningLane)
                                .addGap(32, 32, 32)
                                .addComponent(winnerField)))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 325, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(setupLabel)
                        .addGap(7, 7, 7)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(typeSort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(algLabel))
                        .addGap(28, 28, 28)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(orderLabel)
                            .addComponent(typeOrder, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(24, 24, 24)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(listSizeLabel)
                            .addComponent(sizeList, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(19, 19, 19)
                        .addComponent(listSlider, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(genBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(resultsLabel)
                        .addGap(18, 18, 18)
                        .addComponent(currentAlg, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(amtCompField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(compLabel))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(amtSwapField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(swapLabel))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(amtTimeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(timeLabel))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel2)
                            .addComponent(msTimeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(winnerField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(winningLane))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel1)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        bindingGroup.bind();

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void typeSortActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_typeSortActionPerformed
    {//GEN-HEADEREND:event_typeSortActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_typeSortActionPerformed

    private void genBtnActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_genBtnActionPerformed
    {//GEN-HEADEREND:event_genBtnActionPerformed
        sizeOfList = listSlider.getValue();
        sizeList.setText(String.valueOf(sizeOfList));
        sortMethod = typeSort.getSelectedItem().toString();        
        order = typeOrder.getSelectedItem().toString();
        sortLists();
        amtCompField.setText(String.valueOf(results.get(typeSort.getSelectedIndex()).getComp()));
        amtSwapField.setText(String.valueOf(results.get(typeSort.getSelectedIndex()).getSwap()));
        amtTimeField.setText(results.get(typeSort.getSelectedIndex()).getHMSTime());
        msTimeField.setText(String.valueOf(results.get(typeSort.getSelectedIndex()).getTime()));
        winnerField.setText(winner);
        currentAlg.setText(typeSort.getSelectedItem().toString());
    }//GEN-LAST:event_genBtnActionPerformed

    private void listSliderStateChanged(javax.swing.event.ChangeEvent evt)//GEN-FIRST:event_listSliderStateChanged
    {//GEN-HEADEREND:event_listSliderStateChanged
        sizeList.setText(String.valueOf(listSlider.getValue()));
    }//GEN-LAST:event_listSliderStateChanged

    private void sortLists()
    {
        //Create all possible lists
        results.clear();
        int[] inOrder = new int [sizeOfList];
        int[] mostOrder = new int [sizeOfList];
        int[] reverseOrder = new int [sizeOfList];
        int[] random = new int[sizeOfList];
        double randomnum;
        
        //Assign values to all lists
        for (int i = 0; i < sizeOfList; i++)
        {
            randomnum = Math.random() * 100;
            inOrder[i] = (i + 1);
            reverseOrder[i] = (sizeOfList - (i + 1));
            if (i < sizeOfList - (sizeOfList / 4 ))
                    mostOrder[i] = (i + 1);
            else
                mostOrder[i] = (sizeOfList - (i + 1));
            random[i] = (int)randomnum;
        }//End for
        
        //Generate All Results for the given order of the list
        switch(order)
        {
            case "In Order":
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                insertionSort(inOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Insertion Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                mergeSort(inOrder.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Merge Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                quickSort(inOrder.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Quick Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                selectionSort(inOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Selection Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                heapSort(inOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Heap Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                radixsort(inOrder.clone(), inOrder.length);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Radix Sort", order));
                break;
            case "Reverse Order":
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                insertionSort(reverseOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Insertion Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                mergeSort(reverseOrder.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Merge Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                quickSort(reverseOrder.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Quick Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                selectionSort(reverseOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Selection Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                heapSort(reverseOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Heap Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                radixsort(reverseOrder.clone(), reverseOrder.length);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Radix Sort", order));
                break;
            case "Almost Ordered":
                 timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                insertionSort(mostOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Insertion Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                mergeSort(mostOrder.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Merge Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                quickSort(mostOrder.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Quick Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                selectionSort(mostOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Selection Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                heapSort(mostOrder.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Heap Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                radixsort(mostOrder.clone(), mostOrder.length);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Radix Sort", order));
                break;
            case "Random":
                 timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                insertionSort(random.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Insertion Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                mergeSort(random.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Merge Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                quickSort(random.clone(), 0, sizeOfList - 1);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Quick Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                selectionSort(random.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Selection Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;                
                heapSort(random.clone());
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Heap Sort", order));
                timeTaken = 0;
                amtComp = 0;
                amtSwap = 0;
                radixsort(random.clone(), random.length);
                results.add(new sortResults(sizeOfList, amtComp, amtSwap, timeTaken, "Radix Sort", order));
                break;                               
            default:
        }//End order 
        //Decide winning algorithm
        long winningTime = results.get(0).getTime();
        winner = results.get(0).getMethod();
        for (int i = 0; i < results.size(); i++)
        {
            if (results.get(i).getTime() < winningTime)
                winner = results.get(i).getMethod();
        }
    }//End sortLists
    
    private void selectionSort(int[] array)
    {
        long comparisons = 0,
            assignments = 0;
        long start = System.currentTimeMillis();
        
        for (int i = 0; i < array.length - 1; i++) 
        { 
            int min_idx = i;
            assignments++;
            
            for (int j = i + 1; j < array.length; j++)
            {
                comparisons++;
                if (array[j] < array[min_idx])
                {
                    min_idx = j;
                    assignments++;
                }
            }
            
            assignments = assignments + 3;
            int temp = array[min_idx]; 
            array[min_idx] = array[i]; 
            array[i] = temp; 
        }        
        amtComp = comparisons;
        amtSwap = assignments;
        long end = System.currentTimeMillis();
        timeTaken = end - start;
    }
    
    private void insertionSort(int[] array)
    {
        long start = System.currentTimeMillis();
        long comparisons = 0,
            assignments = 0;
        
        for (int i = 1; i < array.length; i++)
        {
            int currentElement = array[i];
            assignments++;
            
            int k;
            assignments++;
            for (k = i - 1; k >= 0 && array[k] > currentElement; k--)
            {
                comparisons++;
                array[k + 1] = array[k];
                assignments++;
            }
            comparisons++;
            
            array[k + 1] = currentElement;
            assignments++;
        }
        
        amtComp = comparisons;
        amtSwap = assignments;
        long end = System.currentTimeMillis();
        timeTaken = end - start;
    }
    
    private int partition(int arr[], int low, int high) 
    { 
        int pivot = arr[high];  
        int i = (low - 1);
        amtSwap += 2;
        for (int j = low; j< high; j++) 
        {            
            if (arr[j] <= pivot) 
            { 
                i++; 
  
                int temp = arr[i]; 
                arr[i] = arr[j]; 
                arr[j] = temp; 
                amtSwap += 4;
            }//End if 
            amtComp += 2;
        }//End for
  
        int temp = arr[i+1]; 
        arr[i+1] = arr[high]; 
        arr[high] = temp;
        amtSwap += 3;
  
        return i+1; 
    }//End partition
    
     private void quickSort (int arr[], int l, int h) 
    { 
        long start = System.currentTimeMillis();
        // Create an auxiliary stack 
        int[] stack = new int[h-l+1]; 

        // initialize top of stack 
        int top = -1; 

        // push initial values of l and h to stack 
        stack[++top] = l; 
        stack[++top] = h; 
        amtSwap += 4;
        // Keep popping from stack while is not empty 
        while (top >= 0) 
        { 
            // Pop h and l 
            h = stack[top--]; 
            l = stack[top--]; 
            

            // Set pivot element at its correct position 
            // in sorted array 
            int p = partition(arr, l, h); 
            amtSwap += 3;
            // If there are elements on left side of pivot, 
            // then push left side to stack 
            if (p-1 > l) 
            { 
                stack[++top] = l; 
                stack[++top] = p - 1;
                amtSwap +=2;
            }//End if

            // If there are elements on right side of pivot, 
            // then push right side to stack 
            if (p+1 < h) 
            { 
                stack[++top] = p + 1; 
                stack[++top] = h; 
                amtSwap +=2;
            }//End if
            amtComp +=2;
        }//End while 
        long end = System.currentTimeMillis();
        timeTaken = end - start;
    }//End quickSort
     
     void mergeSort(int arr[], int l, int r) 
    { 
        long start = System.currentTimeMillis();
        amtSwap++;
        if (l < r) 
        { 
            // Find the middle point 
            int m = (l+r)/2; 
            amtSwap++;
            // Sort first and second halves 
            mergeSort(arr, l, m); 
            mergeSort(arr , m+1, r); 
  
            // Merge the sorted halves 
            merge(arr, l, m, r); 
        }//End if
        long end = System.currentTimeMillis();
        timeTaken = end - start;
    }//End mergeSort
     
    private void merge(int arr[], int l, int m, int r) 
    { 
        
        int n1 = m - l + 1; 
        int n2 = r - m; 
  
        
        int L[] = new int [n1]; 
        int R[] = new int [n2]; 
  
        amtSwap += 4;
        for (int i=0; i<n1; ++i)
        {
            L[i] = arr[l + i]; 
            amtComp++;
            amtSwap += 2;
        }//End for
        for (int j=0; j<n2; ++j)
        {
            R[j] = arr[m + 1+ j]; 
            amtComp++;
            amtSwap += 2;
        }//End for
  
  
        int i = 0, j = 0; 
        int k = l;
        amtSwap += 3;
        while (i < n1 && j < n2) 
        { 
            if (L[i] <= R[j]) 
            { 
                arr[k] = L[i]; 
                i++; 
                amtSwap += 2;
            } 
            else
            { 
                arr[k] = R[j]; 
                j++;
                amtSwap += 2;
            } 
            k++;
            amtSwap++;
        } 
        while (i < n1) 
        { 
            arr[k] = L[i]; 
            i++; 
            k++; 
            amtSwap += 3;
        } 
  
        while (j < n2) 
        { 
            arr[k] = R[j]; 
            j++; 
            k++; 
            amtSwap += 3;
        }//End while
    }//End merge
    
    private void heapify(int arr[], int n, int i) 
    { 
        int largest = i; // Initialize largest as root 
        int l = 2*i + 1; // left = 2*i + 1 
        int r = 2*i + 2; // right = 2*i + 2 
        amtSwap +=3;
  
        // If left child is larger than root 
        if (l < n && arr[l] > arr[largest])
        {
            largest = l; 
            amtSwap++;
        }
  
        // If right child is larger than largest so far 
        if (r < n && arr[r] > arr[largest])
        {
            largest = r; 
            amtSwap++;
        }
  
        // If largest is not root 
        if (largest != i) 
        { 
            int swap = arr[i]; 
            arr[i] = arr[largest]; 
            arr[largest] = swap; 
  
            // Recursively heapify the affected sub-tree 
            heapify(arr, n, largest); 
        }//End if 
        amtComp += 5;
    }//End heapify
    
    private void heapSort(int arr[]) 
    { 
        long start = System.currentTimeMillis();
        int n = arr.length; 
        amtSwap++;
        // Build heap (rearrange array) 
        for (int i = n / 2 - 1; i >= 0; i--)
        {
            heapify(arr, n, i); 
            amtComp++;
            amtSwap++;
        }//End for
  
        // One by one extract an element from heap 
        for (int i=n-1; i>=0; i--) 
        { 
            // Move current root to end 
            int temp = arr[0]; 
            arr[0] = arr[i]; 
            arr[i] = temp; 
            amtSwap += 3;
            amtComp++;  
            // call max heapify on the reduced heap 
            heapify(arr, i, 0); 
        }//End for
        long end = System.currentTimeMillis();
        timeTaken = end - start;
    }//End heapSort
    
    int getMax(int arr[]) 
    { 
        int max = arr[0]; 
        amtSwap++;
        for (int i = 1; i < arr.length; i++) 
        {
            amtComp++;
            if (arr[i] > max) 
            {
                max = arr[i]; 
                amtSwap++;
            }
        }
        return max; 
    } 
  
    
    void countSort(int arr[], int n, int exp) 
    { 
        int output[] = new int[n]; 
        int i; 
        int count[] = new int[10]; 
        Arrays.fill(count,0); 
        amtComp += 12;
  
        
        for (i = 0; i < n; i++) 
        {
            count[ (arr[i]/exp)%10 ]++; 
            amtComp++;
            amtSwap+= 2;
        }
  
        
        for (i = 1; i < 10; i++) 
        {
            count[i] += count[i - 1];
            amtComp++;
            amtSwap+= 2;
        }
  
        
        for (i = n - 1; i >= 0; i--) 
        { 
            output[count[ (arr[i]/exp)%10 ] - 1] = arr[i]; 
            count[ (arr[i]/exp)%10 ]--; 
            amtComp++;
            amtSwap+= 3;
        } 
  
        
        for (i = 0; i < n; i++) 
        {
            arr[i] = output[i];
            amtComp++;
            amtSwap += 2;
        }
    } 
  
    
    void radixsort(int arr[], int n) 
    { 
        long start = System.currentTimeMillis();
        int max = getMax(arr); 
        amtSwap++;
  
        
        for (int exp = 1; max/exp > 0; exp *= 10)
        {
            countSort(arr, n, exp); 
            amtComp++;
            amtSwap++;
        }
        long end = System.currentTimeMillis();
        timeTaken = end - start;
    } 
  
    
    public static void main(String args[])
    {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try
        {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels())
            {
                if ("Nimbus".equals(info.getName()))
                {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex)
        {
            java.util.logging.Logger.getLogger(listOptions.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex)
        {
            java.util.logging.Logger.getLogger(listOptions.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex)
        {
            java.util.logging.Logger.getLogger(listOptions.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex)
        {
            java.util.logging.Logger.getLogger(listOptions.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable()
        {
            public void run()
            {
                new listOptions().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel algLabel;
    private javax.swing.JTextField amtCompField;
    private javax.swing.JTextField amtSwapField;
    private javax.swing.JTextField amtTimeField;
    private javax.swing.JLabel compLabel;
    private javax.swing.JLabel currentAlg;
    private javax.swing.JButton genBtn;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JLabel listSizeLabel;
    private javax.swing.JSlider listSlider;
    private javax.swing.JTextField msTimeField;
    private javax.swing.JLabel orderLabel;
    private javax.swing.JLabel resultsLabel;
    private javax.swing.JLabel setupLabel;
    private javax.swing.JTextField sizeList;
    private javax.swing.JLabel swapLabel;
    private javax.swing.JLabel timeLabel;
    private javax.swing.JComboBox<String> typeOrder;
    private javax.swing.JComboBox<String> typeSort;
    private javax.swing.JTextField winnerField;
    private javax.swing.JLabel winningLane;
    private org.jdesktop.beansbinding.BindingGroup bindingGroup;
    // End of variables declaration//GEN-END:variables
}
